---
related_hyp: A001
data: results/family_A/A001
periods: 2024_verify + 2025_forward
---

注記：絶対ルール（baseline A001は編集しない）に従い、考察はこの別ノートに集約する。

## Dataview（CSV参照）

```dataviewjs
const paths = {
  verify_m: "results/family_A/A001/in_sample_2024/monthly.csv",
  verify_ms: "results/family_A/A001/in_sample_2024/monthly_by_session.csv",
  forward_m: "results/family_A/A001/forward_2025/monthly.csv",
  forward_ms: "results/family_A/A001/forward_2025/monthly_by_session.csv",
};

async function csvRows(path) {
  const data = await dv.io.csv(path);
  const rows = (data && typeof data.array === "function")
    ? data.array()
    : (Array.isArray(data) ? data : (data?.values ?? []));
  return rows;
}

function num(x) {
  const v = Number(x);
  return Number.isFinite(v) ? v : 0;
}

function summarizeMonthly(rows) {
  const sumPnl = rows.reduce((a, r) => a + num(r.sum_pnl_pips), 0);
  const trades = rows.reduce((a, r) => a + num(r.trades), 0);
  const wins = rows.reduce((a, r) => a + num(r.wins), 0);
  const winrate = trades > 0 ? wins / trades : 0;
  return { sumPnl, trades, wins, winrate };
}

function summarizeBySession(rows) {
  const by = new Map();
  for (const r of rows) {
    const k = String(r.session ?? "NA");
    const cur = by.get(k) ?? { trades: 0, wins: 0, losses: 0, sumPnl: 0 };
    cur.trades += num(r.trades);
    cur.wins += num(r.wins);
    cur.losses += num(r.losses);
    cur.sumPnl += num(r.sum_pnl_pips);
    by.set(k, cur);
  }
  return [...by.entries()].sort((a, b) => a[0].localeCompare(b[0]));
}

const verifyM = await csvRows(paths.verify_m);
const verifyMS = await csvRows(paths.verify_ms);
const forwardM = await csvRows(paths.forward_m);
const forwardMS = await csvRows(paths.forward_ms);

const v = summarizeMonthly(verifyM);
const f = summarizeMonthly(forwardM);

dv.header(3, "集計（2024 verify / 2025 forward）");
dv.table(
  ["period", "sum_pnl_pips", "trades", "wins", "winrate"],
  [
    ["2024 verify", v.sumPnl.toFixed(1), v.trades, v.wins, v.winrate.toFixed(3)],
    ["2025 forward", f.sumPnl.toFixed(1), f.trades, f.wins, f.winrate.toFixed(3)],
  ]
);

dv.header(3, "2025 forward：セッション別合計（W1/W2）");
dv.table(
  ["session", "trades", "wins", "losses", "sum_pnl_pips"],
  summarizeBySession(forwardMS).map(([k, s]) => [k, s.trades, s.wins, s.losses, s.sumPnl.toFixed(1)])
);

dv.header(3, "2025 forward：月次（参考）");
dv.table(
  ["month", "trades", "sum_pnl_pips", "avg_pnl_pips", "winrate"],
  forwardM.map(r => [r.month, num(r.trades), num(r.sum_pnl_pips).toFixed(1), num(r.avg_pnl_pips).toFixed(3), num(r.winrate).toFixed(3)])
);
```

## 考察（この結果から言えること）

- 2025 forward の合計PnLが負で、少なくとも「再現性のある正の期待値」は確認できない。
- セッション別に見ると、2025 forward は `W2` 側の損失寄与が大きい（上のDataview集計参照）。A001メモ内の「W2に正の偏り」という観察は、今回のフォワードでは維持されていない。
- 月次では大きく負ける月が複数あり、勝ち月（例：2025-07）だけでは相殺しきれていない（上の月次テーブル参照）。

## A002 / A003 へのつながり（推察）

- A002（W2 only）：A001のフォワードで `W2` が損失側に寄っているなら、`W2` のみに絞るのは期待値改善になりにくい。実際に A002 の 2025 forward は合計PnLが負で、ここが「dead」判定の直接根拠になった。
- A003（H1なし）：セッション絞り（A002）が効かない場合、次は「上位足フィルター（H1トレンド整合）が本当に損失を減らしているか」を切り分ける価値がある。A003はまさにその価値検証で、A001 vs A003 のフォワード比較で、H1フィルターの寄与（損失削減 or 足かせ）を判定できる。

## A004 / A005 へのつながり（推察）

- A004（M1なし）：A003でH1の寄与を見た後は、「M1シグナルが本当に先行合図として機能しているか」を切り分ける段階になる。もしA001の負け月が“合図（M1）→執行（10s）”の遅れ・ノイズ化に起因しているなら、M1を外した方が改善する可能性がある（逆に、M1が効いているなら悪化するはず）。A004はその寄与（ノイズ除去か足かせか）を判定するための比較になる。
- A005（時間帯なし）：A001の結果がセッション別・月次で大きく揺れる場合、「時間帯フィルター（ロンドン）自体が優位性の源泉か、単にトレード数を絞っているだけか」を切り分ける必要がある。A005で時間帯制限を外し、(1) トレード数増加に対して損益がどう崩れるか、(2) 逆に改善するなら“ロンドン縛りが過適合”だった可能性、を検証できる。
