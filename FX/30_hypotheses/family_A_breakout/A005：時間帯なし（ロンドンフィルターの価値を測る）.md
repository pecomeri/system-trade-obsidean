---
regime: h1_trend_aligned
strategy: topdown_trend_trigger + m1_signal_to_10s_entry
result: dead
---

成立しそうな理由：
- トレンドが強い日は、時間帯依存が弱い可能性がある

壊れやすい理由：
- アジア時間などでスプレッド・値動きが劣化し、トリガーがノイズ化しやすい
- 「結局ロンドンだけだった」が起きやすい

検証で見たいポイント：
- hyp_001との差分＝「ロンドン限定の価値」
- 時間帯で“負け方が変わる”かを見る

裁量トレードでの照合観点：
- 裁量でも「時間帯で同じ形でも質が違う」に一致するか

## 結果（DataviewでCSV参照）

差分の実装（runner）：`use_time_filter=False`（ロンドン時間帯制限を外す）

```dataviewjs
const paths = {
  verify_m: "results/family_A/A005/in_sample_2024/monthly.csv",
  forward_m: "results/family_A/A005/forward_2025/monthly.csv",
  forward_ms: "results/family_A/A005/forward_2025/monthly_by_session.csv",
};

async function csvRows(path) {
  const data = await dv.io.csv(path);
  return (data && typeof data.array === "function")
    ? data.array()
    : (Array.isArray(data) ? data : (data?.values ?? []));
}

function num(x) {
  const v = Number(x);
  return Number.isFinite(v) ? v : 0;
}

function summarizeMonthly(rows) {
  const sumPnl = rows.reduce((a, r) => a + num(r.sum_pnl_pips), 0);
  const trades = rows.reduce((a, r) => a + num(r.trades), 0);
  const wins = rows.reduce((a, r) => a + num(r.wins), 0);
  const winrate = trades > 0 ? wins / trades : 0;
  return { sumPnl, trades, wins, winrate };
}

function summarizeBySession(rows) {
  const by = new Map();
  for (const r of rows) {
    const k = String(r.session ?? "NA");
    const cur = by.get(k) ?? { trades: 0, wins: 0, losses: 0, sumPnl: 0 };
    cur.trades += num(r.trades);
    cur.wins += num(r.wins);
    cur.losses += num(r.losses);
    cur.sumPnl += num(r.sum_pnl_pips);
    by.set(k, cur);
  }
  return [...by.entries()].sort((a, b) => a[0].localeCompare(b[0]));
}

const verifyM = await csvRows(paths.verify_m);
const forwardM = await csvRows(paths.forward_m);
const forwardMS = await csvRows(paths.forward_ms);

const v = summarizeMonthly(verifyM);
const f = summarizeMonthly(forwardM);

dv.header(3, "集計（2024 verify / 2025 forward）");
dv.table(
  ["period", "sum_pnl_pips", "trades", "wins", "winrate"],
  [
    ["2024 verify", v.sumPnl.toFixed(1), v.trades, v.wins, v.winrate.toFixed(3)],
    ["2025 forward", f.sumPnl.toFixed(1), f.trades, f.wins, f.winrate.toFixed(3)],
  ]
);

dv.header(3, "2025 forward：セッション別合計（OUT/W1/W2）");
dv.table(
  ["session", "trades", "wins", "losses", "sum_pnl_pips"],
  summarizeBySession(forwardMS).map(([k, s]) => [k, s.trades, s.wins, s.losses, s.sumPnl.toFixed(1)])
);

dv.header(3, "2025 forward：月次（参考）");
dv.table(
  ["month", "trades", "sum_pnl_pips", "avg_pnl_pips", "winrate"],
  forwardM.map(r => [r.month, num(r.trades), num(r.sum_pnl_pips).toFixed(1), num(r.avg_pnl_pips).toFixed(3), num(r.winrate).toFixed(3)])
);
```

## 考察

- 時間帯制限を外したフォワードが大幅悪化しており、少なくとも「ロンドン限定」は優位性（もしくは損失抑制）の重要な条件である可能性が高い。
- セッション別（OUT/W1/W2）でどこが損失寄与しているかを確認し、もし OUT が主因なら「時間帯を外す＝品質劣化」が示唆される。逆に W1/W2 由来が主なら、時間帯以外（H1/M1/執行）に原因が残る。

理由：時間帯制限を外すとフォワードが大幅悪化（`sum_pnl_pips=-1040`）し、改善が確認できず
